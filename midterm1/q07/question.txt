What are higher order functions?

Did you use any higher order functions in assignment 2? If so, mention one and explain what you used it for and why was that function the right choice for the problem on hand. Refer back to the file and the function from assignment 2 where you use it.

Did you use any higher order functions in assignment 2? If so, mention one and explain what you used it for and why that function was the right choice for the problem on hand. Refer back to the file and the function from assignment 2 where you use it.

Did you use any higher order functions in assignment 2? If so, mention one and explain what you used it for and why that function was the right choice for the problem on hand. Refer back to the file and the function from assignment 2 where you use it.

Higher-order functions are a fundamental feature of functional programming languages, allowing functions to accept other functions as arguments or return them as results. This ability enhances abstraction, simplifies code, and encourages reuse by enabling flexible ways to process and manipulate data while avoiding the need for explicit control flow such as loops and conditionals.

Erlang:
Based on the code, we employed lists:foldl in the iterative implementation for assignment 2. The function lists:foldl is an example of a higher-order function because the function accepts a function as an argument and applies it across elements of a list. 

The function will iterate over a sequence (generated by lists:seq) and accumulate a tuple containing the Fibonacci series and the last two numbers ({Prev, Cur}). The anonymous function (fun(_, {Series, {Prev, Cur}}) ->) takes a dummy value and the tuple, appends the current Fibonacci number (Cur) to the series, and updates the tuple for the next iteration. 

The function lists:foldl was the right choice because the function allows us to compute the Fibonacci sequence iteratively in a single pass over the sequence, reducing the unnecessary recursive calls. This approach preserves functional purity by avoiding mutation of variables. Instead, each iteration produces a new tuple with updated values, ensuring that the original values remain unchanged. Finally, the resulting code is easier to read and improves the maintainability of the code for future modifications.

Total[10]: 10
